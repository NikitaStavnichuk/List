#include <stdio.h> //библиотека с функциями ввода и вывода
#include <windows.h> //библиотека, в которой объявляются функции, предоставляющие интерфейс доступа к Windows API

typedef struct word //структура узла предложения
{
	char* slovo;// данные - слово
	struct word* aft; //указатель на следующее слово
	struct word* bef; //указатель на предыдущее слово
} word;

typedef struct DLList //список
{
	word* head; //начало списка
	word* tail; //конец списка
} DLList;

DLList* createList(void) //функция создания списка
{
	DLList* tmp = (DLList*)malloc(sizeof(DLList)); //динамическое выделение памяти
	if (tmp == NULL) //если память не выделилась
	{
		printf("Проблемы с оперативной памятью компьютера! Завершение программы...\n"); //сообщение пользователю
		return (0); //аварийное завершение программы
	}
	tmp->head = NULL; //обнуляем указатель на предыдущий элемент
	tmp->tail = NULL; //и на следующий элемент
	return tmp; //возвращаем указатель на первый элемент списка
}

void deleteList(DLList* list) //функция удаления списка
{
	word* tmp = list->head; //создаём указатель на начало списка
	word* aft = NULL; //вспомогательный указатель
	while (tmp != NULL)
	{ //пока не конец списка
		aft = tmp->aft; //идём по списку
		free(tmp); //по очереди освобождаем память
		tmp = aft; //и передвигаем указатель вперёд
	}
	free(list); //удаляем список
	list = NULL; //обнуляем указатель на него
}

void empty_list_check(DLList* list) //функция проверки пустоты/не пустоты списка
{
	if (list->head == NULL && list->tail == NULL) //если список действительно пуст
	{
		printf("Список пуст!\n\n"); //сообщение пользователю
	}
	else
	{
		printf("Список не пуст!\n\n"); //сообщение пользователю
	}
}

word* newNode() //функция создания нового узла
{
	word* tmp; //cоздание указателя на новый узел
	tmp = (word*)malloc(sizeof(word)); //динамическое выделение памяти
	if (tmp == NULL) //если память не выделилась
	{
		printf("Проблемы с оперативной памятью компьютера! Завершение программы...\n"); //сообщение пользователю
		return(0); //аварийное завершение программы
	}
	return tmp; //возвращаем указатель на этот узел
}

word* insertNode(word* node, char* c) //функция добавления узла в любое место
{
	word* aft; //указатель на элемент следующий за элементом, на котором стоит указатель
	word* tmp; //указатель на текущий элемент
	aft = node->aft; //запоминаем элемент следующий за текущим
	tmp = newNode(); //создаём новый узел
	if (tmp == 0)
	{
		return 0;
	} //если указатель на текущий элемент равен нулю, аварийно завершаем работу программы
	tmp->slovo = c; //вставляем туда введённый пользователем слово
	tmp->aft = node->aft;
	node->aft = tmp; //новый узел становится за текущим элементом
	if (aft != NULL)
	{ //если указатель на следующий элемент равен NULL
		tmp->bef = aft->bef;
		aft->bef = tmp; //новый узел становится до него
	}
	return tmp; //возвращаем указатель на следующий узел
}

void pushBack(DLList* list, char* c) //добавление узла в конец списка
{
	word* tmp; //cоздание указателя на новый узел
	tmp = newNode(); //создаём новый узел
	tmp->slovo = c; //записываем слово в элемент
	tmp->aft = NULL; //указатель на следующий элемент равен NULL, так как мы в конце списка
	tmp->bef = list->tail; //указатель на предыдущий элемент указывает на конец списка
	if (list->tail == NULL)
	{ //если в конце списка NULL
		list->head = tmp; //указатель на текущий элемент становится в начало списка
	}
	else
	{ //иначе
		list->tail->aft = tmp; //указатель на текущий элемент становится после конца списка
	}
	list->tail = tmp; //приравниваем конец списка текущему указателю
}

void pushFront(DLList* list, char* c) //добавление узла в начало списка
{
	word* tmp; //cоздание указателя на новый узел
	tmp = newNode(); //создаём новый узел
	tmp->slovo = c; //записываем символ в элемент
	tmp->bef = NULL; //укакзатель на предыдущий элемент равен NULL, так как мы в начале спика
	tmp->aft = list->head; //указатель на следующий элемент указывает на начало списка
	if (list->head == NULL) //если в начале спичка NULL
	{
		list->tail = tmp; //указатель на текущий элемент становится в конец списка
	}
	else //иначе
	{
		list->head->bef = tmp; //указатель на текущий элемент становится перед началом списка
	}
	list->head = tmp; //приравниваем начало списка текущему указателю
}

void printList(DLList* list) //функция печати списка
{
	word* tmp; //временный указатель
	tmp = list->head; //он будет указывать на начало списка
	while (tmp != NULL) //пока не последний элемент списка
	{
		int i = 0;
		while (*(tmp->slovo + i) != '\n') //пока не встретим '\n'
		{
			printf("%c", *(tmp->slovo + i)); //посимвольный вывод слова
			i++;
		}
		tmp = tmp->aft; //передвижение указателя на следующее слово
		printf(" "); //пробел после каждого слова
	}
}

void printbackward(DLList* list) //функция вывода списка в обратном порядке
{
	word* tmp; //временный указатель
	tmp = list->tail; //он будет указывать на конец списка
	while (tmp != NULL) //пока он не дойдёт до начала списка
	{
		int i = 0;
		while (*(tmp->slovo + i) != '\n') //пока не встретим '\n'
		{
			printf("%c", *(tmp->slovo + i)); //посимвольный вывод слова
			i++;
		}
		tmp = tmp->bef; //передвижение указателя на предыдущее слово
		printf(" "); //пробел после каждого слова
	}
}

word* sdvig_vlevo(DLList* list, word* tmp) //функция сдвига рабочего указателя влево
{
	if (list->head != NULL && list->tail != NULL) //если список не пуст
	{
		if (tmp->bef != NULL) //если текущий указатель стоит не в начале списка
		{
			tmp = tmp->bef; //сдвигаем его влево
			printf("Рабочий указатель передвинут влево!\n"); //сообщение пользователю
		}
		else
		{ //если указатель стоит в начале списка
			tmp = list->tail; //передвинуть рабочий указатель в конец списка
			printf("Рабочий указатель передвинут влево, перейдя в конец списка.\n"); //сообщение пользователю
		}
	}
	else
	{
		printf("Это нельзя сделать, так как список пуст.\n"); //сообщение пользователю
	}
	return (tmp); //возвращаем текущий указатель
}

word* sdvig_vpravo(DLList* list, word* tmp) //функция сдвига рабочего указателя вправо
{
	if (list->head != NULL && list->tail != NULL) //если список не пуст
	{
		if (tmp->aft != NULL) //если текущий указатель стоит не в конце списка
		{
			tmp = tmp->aft; //сдвигаем его вправо
			printf("Рабочий указатель передвинут вправо!\n"); //сообщение пользователю
		}
		else
		{
			tmp = list->head; //передвинуть рабочий указатель в начало списка
			printf("Рабочий указатель передвинут вправо, перейдя в начало списка.\n"); //сообщение пользователю
		}
	}
	else
	{
		printf("Это нельзя сделать, так как список пуст.\n"); //сообщение пользователю
	}
	return (tmp); //возвращаем текущий указатель
}

word* point_begin(DLList* list, word* tmp) //функция установки рабочего указателя на начало списка
{
	if (list->head != NULL && list->tail != NULL) //если список не пуст
	{
		if (tmp == list->head) //если рабочий указатель на начале списка
		{
			printf("Рабочий указатель уже установлен на начало списка!\n");
			//сообщение пользователю
		}
		else
		{
			tmp = list->head; //установить рабочий указатель на начало списка
			printf("Рабочий указатель установлен на начало списка!\n"); //сообщение пользователю
		}
	}
	else
	{
		printf("Это нельзя сделать, так как список пуст.\n"); //сообщение пользователю
	}
	return (tmp); //возвращаем текущий указатель
}

word* point_end(DLList* list, word* tmp) //функция установки рабочего указателя на конец списка
{
	if (list->head != NULL && list->tail != NULL) //если список не пуст
	{
		if (tmp == list->tail) //если рабочий указатель на конце списка
		{
			printf("Рабочий указатель уже стоит на конце списка!\n"); //сообщение пользователю
		}
		else
		{
			tmp = list->tail; //установить рабочий указатель на конец списка
			printf("Рабочий указатель установлен на конец списка!\n"); //сообщение пользователю
		}
	}
	else
	{
		printf("Это нельзя сделать, так как список пуст.\n"); //сообщение пользователю
	}
	return (tmp); //возвращаем текущий указатель
}

void checking_begin(DLList* list, word* tmp) //функция проверки нахождения рабочего указателя в начале списка
{
	if (list->head != NULL && list->tail != NULL) //если список не пуст
	{
		if (tmp->aft == NULL && tmp->bef == NULL) //если список состоит из одного элемента
		{
			printf("В списке один элемент, поэтому рабочий указатель стоит и на конце, и на начале\n"); //сообщение пользователю
		}
		else
		{
			if (tmp == list->head) //если рабочий указатель указывает на конец списка
			{
				printf("Рабочий указатель указывает на начало списка!\n"); //сообщение пользователю
			}
			else
			{
				printf("Рабочий указатель указывает НЕ на начало списка!\n"); //сообщение пользователю
			}
		}
	}
	else
	{
		printf("Это нельзя сделать, так как список пуст.\n"); //сообщение пользователю
	}
}

void checking_end(DLList* list, word* tmp) //функция проверки нахождения рабочего указателя в начале списка
{
	if (list->head != NULL && list->tail != NULL) //если список не пуст
	{
		if (tmp->aft == NULL && tmp->bef == NULL) //если список состоит из одного элемента
		{
			printf("В списке один элемент, поэтому рабочий указатель стоит и на конце, и на начале\n"); //сообщение пользователю
		}
		else
		{
			if (tmp == list->tail) //если рабочий указатель указывает на конец списка
			{
				printf("Рабочий указатель указывает на конец списка!\n"); //сообщение пользователю
			}
			else
			{
				printf("Рабочий указатель указывает НЕ на конец списка!\n"); //сообщение пользователю
			}
		}
	}
	else
	{
		printf("Это нельзя сделать, так как список пуст.\n"); //сообщение пользователю
	}
}

void print_elem_bef(DLList* list, word* tmp) //функция вывода слова до рабочего указателя
{
	word* bef = NULL;
	if (list->head != NULL && list->tail != NULL) //если список не пуст
	{
		if (tmp->aft == NULL && tmp->bef == NULL) //если список состоит из одного элемента
		{
			printf("В списке содержится один элемент, операция выведет единственное содержащееся в списке слово : "); //сообщение пользователю
			int i = 0; //переменная для посимвольного вывода
			while (*(tmp->slovo + i) != '\n')
			{
				printf("%c", *(tmp->slovo + i)); //посимвольный вывод слова
				i++; //инкремент
			}
			printf("\n"); //отступ после вывода
		}
		else
		{
			if (tmp->bef != NULL) //если текущий указатель стоит не в начале списка
			{
				int i = 0;
				bef = tmp->bef;
				printf("Значение слова, стоящего до рабочего указателя: "); //сообщение пользователю
				while (*(bef->slovo + i) != '\n')
				{
					printf("%c", *(bef->slovo + i)); //посимвольный вывод слова
					i++; //инкремент
				}
				printf("\n"); //отступ после вывода
			}
			else //если указатель стоит в начале списка
			{
				bef = list->tail; //передвинуть рабочий указатель в конец списка
				int i = 0;
				printf("Значение слова, стоящего до рабочего указателя: "); //сообщение пользователю
				while (*(bef->slovo + i) != '\n')
				{
					printf("%c", *(bef->slovo + i)); //посимвольный вывод слова
					i++; //инкремент
				}
				printf("\n"); //отступ после вывода
			}
		}
	}
	else
	{
		printf("Это нельзя сделать, так как список пуст.\n"); //сообщение пользователю
	}
}

void print_elem_aft(DLList* list, word* tmp) //функция вывода слова после рабочего указателя
{
	word* aft = NULL;
	if (list->head != NULL && list->tail != NULL) //если список не пуст
	{
		if (tmp->aft == NULL && tmp->bef == NULL) //есил список состоит из одного элемента
		{
			printf("В списке содержится один элемент, операция выведет единственное содержащееся в списке слово : "); //сообщение пользователю
			int i = 0;
			while (*(tmp->slovo + i) != '\n')
			{
				printf("%c", *(tmp->slovo + i)); //посимвольный вывод слова
				i++; //инкремент
			}
			printf("\n"); //отступ после вывода
		}
		else
		{
			if (tmp->aft != NULL)
			{ //если текущий указатель стоит не в начале списка
				int i = 0;
				aft = tmp->aft;
				printf("Значение слова, стоящего до рабочего указателя: ");
				//сообщение пользователю
				while (*(aft->slovo + i) != '\n')
				{
					printf("%c", *(aft->slovo + i)); //посимвольный вывод слова
					i++; //инкремент
				}
				printf("\n"); //отступ после вывода
			}
			else
			{ //если указатель стоит в конце списка
				aft = list->head; //передвинуть рабочий указатель в конец списка
				int i = 0;
				printf("Значение слова, стоящего до рабочего указателя: ");
				//сообщение пользователю
				while (*(aft->slovo + i) != '\n')
				{
					printf("%c", *(aft->slovo + i)); //посимвольный вывод слова
					i++; //инкремент
				}
				printf("\n"); //отступ после вывода
			}
		}
	}
	else
	{
		printf("Это нельзя сделать, так как список пуст.\n"); //сообщение пользователю
	}
}

word* deleteNode(DLList* list, word* node) //функция удаление узла
{
	word* tmp; //создаём указатель на текущий элемент
	tmp = node->aft; //теперь он указывает на элемент после удаляемого
	if (tmp != NULL)
	{ //если текущий указатель указывает на конец списка
		tmp->bef = node->bef; //текущий указатель указывает на элемент после удаляемого
	}
	if (node != list->head && node != list->tail)
	{
		tmp = node->bef; //текущий указатель становится на место удаляемого элемента
		if (tmp != NULL)
		{ //если он равен NULL
			tmp->aft = node->aft; //то он полностью заменит удаляемый элемент
		}
	}
	if (node == list->head)
	{
		list->head = tmp;
		list->head->bef = NULL;
	} //если удаляется первый элемент, то заменяем его следующим
	if (node == list->tail)
	{
		list->tail = list->tail->bef;
		list->tail->aft = NULL;
	} //если удаляется последний элемент, то заменяем его предыдущим
	free(node); //удаляемый ненужный узел
	return tmp; //возвращаем текущий указатель
}

void cut_before(DLList* list, word* tmp) //функция взятия элемента до рабочего указателя
{
	word* bef = NULL;
	if (list->head != NULL && list->tail != NULL) //если список не пуст
	{
		if (tmp->aft == NULL && tmp->bef == NULL) //если список состоит из одного элемента
		{
			printf("В списке содержится один элемент, взятие элементов невозможно\n"); //сообщение пользователю
		}
		else
		{
			if (tmp->bef != NULL) //если текущий указатель не на начале списка
			{
				printf("Взят следующий элемент списка - "); //сообщение пользователю
				int i = 0; //переменная для посимвольного вывода
				bef = tmp->bef; //запоминаем предыдущий до рабочего указателя элемент
				while (*(bef->slovo + i) != '\n') //пока не встретим '\n'
				{
					printf("%c", *(bef->slovo + i)); //посимвольный вывод слова
					i++;
				}
				deleteNode(list, tmp->bef); //удаление этого слова
				printf("\n"); //необходимый отступ после взятия элемента
			}
			else
			{
				printf("Взят следующий элемент списка (конец списка) - ");
				//сообщение пользователю
				int i = 0; //переменная для посимвольного вывода
				bef = list->tail; //запоминаем последний элемент списка
				while (*(bef->slovo + i) != '\n') //пока не встретим '\n'
				{
					printf("%c", *(bef->slovo + i)); //посимвольный вывод слова
					i++;
				}
				deleteNode(list, list->tail); //удаление этого слова
				printf("\n"); //необходимый отступ после взятия элемента
			}
		}
	}
	else
	{
		printf("Это нельзя сделать, так как список пуст!\n"); //сообщение пользователю
	}
}

void cut_after(DLList* list, word* tmp) //функция взятия элемента после рабочего указателя
{
	word* aft = NULL;
	if (list->head != NULL && list->tail != NULL) //если список не пуст
	{
		if (tmp->aft == NULL && tmp->bef == NULL) //если список состоит из одного элемента
		{
			printf("В списке содержится один элемент, взятие элементов невозможно\n"); //сообщение пользователю
		}
		else
		{
			if (tmp->aft != NULL) //если текущий указатель не на конце списка
			{
				printf("Взят следующий элемент списка - "); //сообщение пользователю
				int i = 0; //переменная для посимвольного вывода
				aft = tmp->aft; //запоминаем следующий после рабочего указателя элемент
				while (*(aft->slovo + i) != '\n') //пока не встретим '\n'
				{
					printf("%c", *(aft->slovo + i)); //посимвольный вывод слова
					i++;
				}
				deleteNode(list, tmp->aft); //удаление этого слова
				printf("\n"); //необходимый отступ после взятия элемента
			}
			else
			{
				printf("Взят следующий элемент списка (начало списка) - ");
				//сообщение пользователю
				int i = 0; //переменная для посимвольного вывода
				aft = list->head; //запоминаем первый элемент списка
				while (*(aft->slovo + i) != '\n') //пока не встретим '\n'
				{
					printf("%c", *(aft->slovo + i)); //посимвольный вывод слова
					i++;
				}
				deleteNode(list, list->head); //удаление этого слова
				printf("\n"); //необходимый отступ после взятия элемента
			}
		}
	}
	else
	{
		printf("Это нельзя сделать, так как список пуст!\n"); //сообщение пользователю
	}
}

int change_before(DLList* list, word* tmp) //функция для замены слова до рабочего указателя
{
	if (list->head != NULL && list->tail != NULL) //если список не пуст
	{
		if (tmp->aft == NULL && tmp->bef == NULL) // если список состоит из одного слова
		{
			printf("В списке содержится один элемент, поменять значение элемента невозможно!\n"); //сообщение пользователю
		}
		else
		{
			if (tmp->bef != NULL) //если рабочий указатель не на начале списка
			{
				printf("Введите новое слово, которое нужно заменить до рабочего указателя:\n"); //сообщение пользователю
				int i = 0; //переменная для посимвольного ввода слова
				int flag; //переменная для проверки корректного ввода
				char c; //переменная для ввода перехода на новую строку
				char* change; //новое слово
				change = (char*)malloc(sizeof(char)); //динамическое выделение памяти под первый символ нового слова
				if (change == NULL) //проверка на выделение памяти
				{
					free(change); //высвобождение памяти
					printf("Ошибка с выделением памяти операционной системой. Аварийное завершение программы...\n"); //сообщение пользователю
					return(0); //аварийное завершение программы
				}
				c = getchar(); //ввод '\n'
				*(change) = getchar(); // ввод первого символа нового слова
				while (*(change + i) != '\n') //цикл посимвольного ввода, пока не встретим '\n'
				{
					i++; //инкремент
					change = (char*)realloc(change, (1 + i) * sizeof(char)); //в случае ввода слова с символами больше одного выделяется память под каждый символ
					if (change == NULL) //проверка на выделение памяти
					{
						free(change); //высвобождение памяти
						printf("Ошибка с выделением памяти операционной системой.Аварийное завершение программы...\n\n"); //сообщение пользователю
						return(0); //aварийное завершение программы
					}
					*(change + i) = getchar(); //посимвольный ввод
				}
				i = 0; //зануляем i для проверки корректного ввода
				flag = 0; //"флажок" не поднят
				while (*(change + i) != '\n') //пока не встретим '\n'
				{
					if (*(change + i) == ' ') //если в вводимом слове содержится пробелы, т.е.введено два и более слова
					{
						printf("Введите ОДНО слово !\n"); //сообщение пользователю
						flag = 1; //"флажок" поднят
						break; //ввод прекращается до тех пор, пока пользователь не введёт одно слово
					}
					i++;
				}
				if (flag == 0) //если ввод коррекнтый
				{
					i = 0; //зануляем i для передачи символов
					while (*(change + i) != '\n') //пока не встретим '\n'
					{
						tmp->bef->slovo = change; //посимвольно меняем символы старого слова на символы нового слова
						i++; //инкремент
					}
				}
			}
			else
			{
				printf("Введите новое слово, которое нужно заменить до рабочего указателя:\n"); //сообщение пользователю
				int i = 0; //переменная для посимвольного ввода слова
				int flag; //переменная для проверки корректного ввода
				char c; //переменная для ввода перехода на новую строку
				char* change; //новое слово
				change = (char*)malloc(sizeof(char)); //динамическое выделение памяти под первый символ нового слова
				if (change == NULL) //проверка на выделение памяти
				{
					free(change); //высвобождение памяти
					printf("Ошибка с выделением памяти операционной системой. Аварийное завершение программы...\n"); //сообщение пользователю
					return(0); //аварийное завершение программы
				}
				c = getchar(); //ввод '\n'
				*(change) = getchar(); // ввод первого символа нового слова
				while (*(change + i) != '\n') //цикл посимвольного ввода, пока не встретим '\n'
				{
					i++; //инкремент
					change = (char*)realloc(change, (1 + i) * sizeof(char)); //в случае ввода слова с символами больше одного выделяется память под каждый символ
					if (change == NULL) //проверка на выделение памяти
					{
						free(change); //высвобождение памяти
						printf("Ошибка с выделением памяти операционной системой.Аварийное завершение программы...\n\n"); //сообщение пользователю
						return(0); //aварийное завершение программы
					}
					*(change + i) = getchar(); //посимвольный ввод
				}
				i = 0; //зануляем i для проверки корректного ввода
				flag = 0; //"флажок" не поднят
				while (*(change + i) != '\n') //пока не встретим '\n'
				{
					if (*(change + i) == ' ') //если в вводимом слове содержится пробелы, т.е.введено два и более слова
					{
						printf("Введите ОДНО слово !\n"); //сообщение пользователю
						flag = 1; //"флажок" поднят
						break; //ввод прекращается до тех пор, пока пользователь не введёт одно слово
					}
					i++; //инкремент
				}
				if (flag == 0) //если ввод коррекнтый
				{
					i = 0; //зануляем i для передачи символов
					while (*(change + i) != '\n') //пока не встретим '\n'
					{
						list->tail->slovo = change; //посимвольно меняем символы старого слова на символы нового слова
							i++; //инкремент
					}
				}
			}
		}
	}
	else
	{
		printf("Это нельзя сделать, так как список пуст!\n"); //сообщение пользователю
	}
}

int change_after(DLList* list, word* tmp) //функция для замены слова после рабочего указателя
{
	if (list->head != NULL && list->tail != NULL) //если список не пуст
	{
		if (tmp->aft == NULL && tmp->bef == NULL) // если список состоит из одного слова
		{
			printf("В списке содержится один элемент, поменять значение элемента невозможно!\n"); //сообщение пользователю
		}
		else
		{
			if (tmp->aft != NULL) //если рабочий указатель не на конце списка
			{
				printf("Введите новое слово, которое нужно заменить до рабочего указателя:\n"); //сообщение пользователю
				int i = 0; //переменная для посимвольного ввода слова
				int flag; //переменная для проверки корректного ввода
				char c; //переменная для ввода перехода на новую строку
				char* change; //новое слово
				change = (char*)malloc(sizeof(char)); //динамическое выделение памяти под первый символ нового слова
				if (change == NULL) //проверка на выделение памяти
				{
					free(change); //высвобождение памяти
					printf("Ошибка с выделением памяти операционной системой. Аварийное завершение программы...\n"); //сообщение пользователю
					return(0); //аварийное завершение программы
				}
				c = getchar(); //ввод '\n'
				*(change) = getchar(); //ввод первого символа нового слова
				while (*(change + i) != '\n') //цикл посимвольного ввода, пока не встретим '\n'
				{
					i++; //инкремент
					change = (char*)realloc(change, (1 + i) * sizeof(char)); //в случае ввода слова с символами больше одного выделяется память под каждый символ
					if (change == NULL) //проверка на выделение памяти
					{
						free(change); //высвобождение памяти
						printf("Ошибка с выделением памяти операционной системой.Аварийное завершение программы...\n\n"); //сообщение пользователю
						return(0); //aварийное завершение программы
					}
					*(change + i) = getchar(); //посимвольный ввод
				}
				i = 0; //зануляем i для проверки корректного ввода
				flag = 0; //"флажок" не поднят
				while (*(change + i) != '\n') //пока не встретим '\n'
				{
					if (*(change + i) == ' ') //если в вводимом слове содержится пробелы, т.е.введено два и более слова
					{
						printf("Введите ОДНО слово !\n"); //сообщение пользователю
						flag = 1; //"флажок" поднят
						break; //ввод прекращается до тех пор, пока пользователь не введёт одно слово
					}
					i++; //инкремент
				}
				if (flag == 0) //если ввод коррекнтый
				{
					i = 0; //зануляем i для передачи символов
					while (*(change + i) != '\n') //пока не встретим '\n'
					{
						tmp->aft->slovo = change; //посимвольно меняем символы старого слова на символы нового слова
						i++; //инкремент
					}
				}
			}
			else
			{
				printf("Введите новое слово, которое нужно заменить до рабочего указателя:\n"); //сообщение пользователю
				int i = 0; //переменная для посимвольного ввода слова
				int flag; //переменная для проверки корректного ввода
				char c; //переменная для ввода перехода на новую строку
				char* change; //новое слово
				change = (char*)malloc(sizeof(char)); //динамическое выделение памяти под первый символ нового слова
				if (change == NULL) //проверка на выделение памяти
				{
					free(change); //высвобождение памяти
					printf("Ошибка с выделением памяти операционной системой. Аварийное завершение программы...\n"); //сообщение пользователю
					return(0); //аварийное завершение программы
				}
				c = getchar(); //ввод '\n'
				*(change) = getchar(); //ввод первого символа нового слова
				while (*(change + i) != '\n') //цикл посимвольного ввода, пока не встретим '\n'
				{
					i++; //инкремент
					change = (char*)realloc(change, (1 + i) * sizeof(char)); //в случае ввода слова с символами больше одного выделяется память под каждый символ
					if (change == NULL) //проверка на выделение памяти
					{
						free(change); //высвобождение памяти
						printf("Ошибка с выделением памяти операционной системой.Аварийное завершение программы...\n\n"); //сообщение пользователю
						return(0); //aварийное завершение программы
					}
					*(change + i) = getchar(); //посимвольный ввод
				}
				i = 0; //зануляем i для проверки корректного ввода
				flag = 0; //"флажок" не поднят
				while (*(change + i) != '\n') //пока не встретим '\n'
				{
					if (*(change + i) == ' ') //если в вводимом слове содержится пробелы, т.е.введено два и более слова
					{
						printf("Введите ОДНО слово !\n"); //сообщение пользователю
						flag = 1; //"флажок" поднят
						break; //ввод прекращается до тех пор, пока пользователь не введёт одно слово
					}
					i++; //инкремент
				}
				if (flag == 0) //если ввод коррекнтый
				{
					i = 0; //зануляем i для передачи символов
					while (*(change + i) != '\n') //пока не встретим '\n'
					{
						list->head->slovo = change; //посимвольно меняем символы старого слова на символы нового слова
						i++; //инкремент
					}
				}
			}
		}
	}
	else
	{
		printf("Это нельзя сделать, так как список пуст!\n"); //сообщение пользователю
	}
}
int menu(DLList* list) //функция menu принимает на вход указатель на список
{
	int flag; //переменная для проверки корректного ввода слов
	int i; //переменная для посимвольного ввода слов
	char* str; //инициализация слова
	word* tmp = list->head; //создам указатель на начало списка
	int comm = 0; //команда пользователя
	system("cls"); //очистка строки
	while (comm != 20) //пока команда НЕ 20
	{
		printf("Выберите, что должна сделать программа:\n\n"); //сообщение пользователю
		if (list->head == NULL && list->tail == NULL) //если список пуст
		{
			printf("(1) - Добавить первый элемент;\n\n");
		}
		printf("(2) - Очистить список;\n\n");
		printf("(3) - Проверка: список пуст/не пуст?\n\n");
		printf("(4) - Установить рабочий указатель на начало списка;\n\n");
		printf("(5) - Установить рабочий указатель на конец списка;\n\n");
		printf("(6) - Проверка: рабочий указатель стоит на начале списка?\n\n");
		printf("(7) - Проверка: рабочий указатель стоит на конце списка?\n\n");
		printf("(8) - Переместить рабочий указатель вправо;\n\n");                        //вывод пунктов меню
		printf("(9) - Переместить рабочий указатель влево;\n\n");
		printf("(10) - Вывести значение элемента списка до рабочего указателя;\n\n");
		printf("(11) - Вывести значение элемента списка после рабочего указателя;\n\n");
		printf("(12) - Удалить элемент списка до рабочего указателя;\n\n");
		printf("(13) - Удалить элемент списка после рабочего указателя;\n\n");
		printf("(14) - Взять элемент списка до рабочего указателя\n\n");
		printf("(15) - Взять элемент списка после рабочего указателя\n\n");
		printf("(16) - Изменить значение элемента спиcка до рабочего указателя\n\n");
		printf("(17) - Изменить значение элемента спиcка после рабочего указателя\n\n");
		printf("(18) - Добавить элемент списка до рабочего указателя;\n\n");
		printf("(19) - Добавить элемент списка после рабочего указателя;\n\n");
		printf("(20) - Завершение работы со списком;\n\n");
		printf("(21) - Вывести список наоборот;\n\n");
		scanf_s("%d", &comm); //ввод команды пользователя
		word* s = list->head; //эти указатели понадобятся при визуальном отображении указателя на текущий элемент
		word* t = list->tail;
		system("cls"); //очистка консоли
		if (comm > 21 || comm < 1)
		{
			printf("Введите значение от 1 до 21\n");
		}
		if (comm == 1) //если команда 1
		{
			char c; //символьный тип для ввода первого элемента
			i = 0; //переменная для посимвольного ввода слов
			str = (char*)malloc(sizeof(char)); //выделение памяти под первый символ
			if (str == NULL) //проверка на выделение памяти
			{
				free(str); //высвобождение памяти
				printf("Ошибка с выделением памяти операционной системой. Аварийное завершение программы...\n"); //сообщение пользователю
				return(0); //аварийное завершение программы
			}
			c = getchar(); //ввод первого символа
			printf("Введите первый элемент списка, являющийся словом:\n");
			//сообщение пользователю
			*(str) = getchar();
			while (*(str + i) != '\n') //цикл посимвольного ввода, пока не встретим '\n'
			{
				i++;
				str = (char*)realloc(str, (1 + i) * sizeof(char)); //в случае ввода слова с символами больше одного выделяется память под каждый символ
				if (str == NULL) //проверка на выделение памяти
				{
					free(str); //высвобождение памяти
					printf("Ошибка с выделением памяти операционной системой. Аварийное завершение программы...\n\n"); //сообщение пользователю
					return(0); //aварийное завершение программы
				}
				*(str + i) = getchar(); //посимвольный ввод
			}
			i = 0;
			flag = 0;
			while (*(str + i) != '\n') //в случае, ечли введено несколько слов вместо одного слово
			{ //вызывается проверка
				if (*(str + i) == ' ') //если в вводимом слове содержится пробел
				{
					printf("Введите ОДНО слово !\n"); //сообщение пользователю
					flag = 1;
					break; //ввод прекращается до тех пор, пока пользователь не введёт одно слово
				}
				i++;
			}
			if (flag == 0) //если введено одно слово
			{
				pushFront(list, str); //вставляем его в начало списка
				s = list->head; //вспомогательный указатель смотрит на новое начало списка
				t = list->tail; //вспомогательный указатель смотрит на новый конец списка
				tmp = list->head; //текущий указатель смотрит на новое начало списка
			}
		}
		if (comm == 2) //если команда 2
		{
			if (list->head == NULL && list->tail == NULL) //если список пуст
			{
				printf("Список и так пуст!\n"); //сообщение пользователю
			}
			else
			{
				deleteList(list); //удаляем список
				list = createList(); //и создаём новый пустой список
				tmp = list->head; //текущий указатель смотрит на новое начало списка
				printf("Список очищен!\n\n"); //сообщение пользователю
			}
		}
		if (comm == 3) //если команда 3
		{
			empty_list_check(list); //проверка на пустоту списка
		}
		if (comm == 4) //если команда 4
		{
			tmp = point_begin(list, tmp); //устанавливаем указатель в начало списка
		}
		if (comm == 5) //если команда 5
		{
			tmp = point_end(list, tmp); //устанавливаем указатель в конец списка
		}
		if (comm == 6) //если команда 6
		{
			checking_begin(list, tmp); //проверяем указатель на начало списка
		}
		if (comm == 7) //если команда 7
		{
			checking_end(list, tmp); //проверяем указатель на конец списка
		}
		if (comm == 8) //если команда 8
		{
			tmp = sdvig_vpravo(list, tmp); //сдвиг рабочего указателя вправо
		}
		if (comm == 9) //если команда 9
		{
			tmp = sdvig_vlevo(list, tmp); //сдвиг рабочего указателя влево
		}
		if (comm == 10) //если команда 10
		{
			print_elem_bef(list, tmp); //вывод слова до рабочего указателя
		}
		if (comm == 11) //если команда 11
		{
			print_elem_aft(list, tmp); //вывод слова после рабочего
		}
		if (comm == 12) //если команда 12
		{
			if (list->head != NULL && list->tail != NULL) //если список не пуст
			{
				if (tmp->aft == NULL && tmp->bef == NULL) //есил список состоит из одного элемента
				{
					printf("Удаление элементов не производится, так как список состоит из одного элемента\n"); //сообщение пользователю
				}
				else
				{
					if (tmp->bef != NULL)
					{
						deleteNode(list, tmp->bef); //удаляем элемент стоящий до рабочего указателя
						printf("Элемент списка, стоящий до рабочего указателя, удалён.\n");
						s = list->head;
						t = list->tail;
					}
					else
					{
						t = list->tail->bef; //запоминаем последний элемент
						deleteNode(list, list->tail); //удаляем последний элемент
						list->tail = t;
						s = list->head; //последний элемент - предыдущий от последнего до удаления
						printf("Удалён последний элемент списка, так как рабочий указатель установлен на начало списка!\n"); //сообщение пользователю
					}
				}
			}
			else
			{
				printf("Это нельзя сделать, так как список пуст.\n"); //сообщение пользователю
			}
		}
		if (comm == 13) //если команда 13
		{
			if (list->head != NULL && list->tail != NULL) //если список не пуст
			{
				if (tmp->aft == NULL && tmp->bef == NULL) //есил список состоит из одного элемента
				{
					printf("Удаление элементов не производится, так как список состоит из одного элемента\n"); //сообщение пользователю
				}
				else
				{
					if (tmp->aft != NULL)
					{
						deleteNode(list, tmp->aft);
						printf("Элемент списка, стоящий до рабочего указателя, удалён.\n"); //сообщение пользователю
						s = list->head;
						t = list->tail;
					}
					else
					{
						s = list->head->aft; //запоминаем первый элемент
						deleteNode(list, list->head); //удаляем первый элемент
						list->head = s; //первый элемент - следующий после первого до удаления
						t = list->tail;
						printf("Удалён первый элемент списка, так как рабочий указатель установлен на конец списка!\n"); //сообщение пользователю
					}
				}
			}
			else
			{
				printf("Это нельзя сделать, так как список пуст.\n"); //сообщение пользователю
			}
		}
		if (comm == 14) //если команда 14
		{
			cut_before(list, tmp); //вырезаем элемент до указателя
			t = list->tail; //конец списка мог измениться
			s = list->head; //начало спика могло измениться
		}
		if (comm == 15) //если команда 15
		{
			cut_after(list, tmp); //взятие элемента после рабочего указателя
			t = list->tail; //конец списка мог измениться
			s = list->head; //начало списка могло измениться
		}
		if (comm == 16) //если команда 15
		{
			change_before(list, tmp);
		}
		if (comm == 17) //если команда 17
		{
			change_after(list, tmp);
		}
		if (comm == 18) //если команда 18
		{
			if (list->head != NULL && list->tail != NULL)
			{
				char c; // переменная для ввода пробела
				char* str = NULL; //инициализация вводимого слова
				printf("Введите элемент, который нужно добавить ДО рабочего указателя\n"); //сообщение пользователю
				c = getchar(); //ввод пробела
				str = (char*)malloc(sizeof(char)); //динамическое выделение памяти под один символ
				if (str == NULL) //проверка на выделение памяти
				{
					free(str); //высвобождение памяти
					printf("Ошибка с выделением памяти операционной системой. Аварийное завершение программы...\n"); //сообщение пользователю
					return(0); //аварийное завершение программы
				}
				*(str) = getchar(); //ввод первого символа
				i = 0; //счётчик - условная длина слова
				while (*(str + i) != '\n') //пока не встретим переход на новую строку при вводе
				{
					i++; //инкремент
					str = (char*)realloc(str, (1 + i) * sizeof(char)); //в случае необходимости добавление памяти под другие символы
					if (str == NULL) //проверка на выделение памяти
					{
						free(str); //высвобождение памяти
						printf("Ошибка с выделением памяти операционной системой.Аварийное завершение программы...\n"); //сообщение пользователю
						return(0); //аварийное завершение программы
					}
					*(str + i) = getchar(); //ввод полного слова
				}
				i = 0; //переменная для посимвольного ввода слова
				flag = 0; //переменная для проверки посимвольного ввода
				while (*(str + i) != '\n') //пока не встретим '\n'
				{
					if (*(str + i) == ' ') //если вводится два и более слов (встречается пробел)
					{
						printf("введите ОДНО слово !\n"); //сообщение пользователю
						flag = 1; //"поднимается" флажок до тех пор, пока не будут введены корректные данные
						break;
					}
					i++;
				}
				if (flag == 0) //если введено корректное значение
				{
					if (tmp != NULL) //если указатель ненулевой
					{
						if (tmp->aft == NULL && tmp->bef == NULL) //если список из одного слова
						{
							printf("В списке содержится один элемент, новый элемент добавлен до рабочего указателя\n"); //сообщение пользователю
							pushFront(list, str); //добавляем элемент
							s = list->head; //рабочий указатель сохраняется
							t = list->tail;
						}
						else
						{
							if (tmp->bef != NULL) //если рабочий указатель не на начале списка
							{
								insertNode(tmp->bef, str); //добавляем элемент до рабочего указателя
							}
							else
							{
								pushBack(list, str); //иначе добавляем элемент в конец списка
								s = list->head; //рабочий указатель сохраняется
								t = list->tail;
							}
						}
					}
					else
					{
						pushBack(list, str); //добавляем элемент
					}
				}
			}
			else
			{
				printf("Сначала введите первый элемент!\n"); //сообщение пользователю
			}
		}
		if (comm == 19) //если команда 19
		{
			if (list->head != NULL && list->tail != NULL)
			{
				char c; // переменная для ввода пробела
				char* str; //инициализация вводимого слова
				i = 0; //счётчик - условная длина слова
				printf("Введите слово, которое нужно добавить ПОСЛЕ рабочего указателя:\n"); //сообщение пользователю
				str = (char*)malloc(sizeof(char)); //динамическое выделение памяти под один символ
				if (str == NULL) //проверка на выделение памяти
				{
					free(str); //высвобождение памяти
					printf("Ошибка с выделением памяти операционной системой. Аварийное завершение программы...\n"); //сообщение пользователю
					return(0); //аварийное завершение программы
				}
				c = getchar(); //ввод пробела
				*(str) = getchar(); //ввод первого символа
				while (*(str + i) != '\n') //пока не встретим переход на новую строку при вводе
				{
					i++; //инкремент
					str = (char*)realloc(str, (1 + i) * sizeof(char)); //в случае необходимости добавление памяти под другие символы
					if (str == NULL) //проверка на выделение памяти
					{
						free(str); //высвобождение памяти
						printf("Ошибка с выделением памяти операционной системой.Аварийное завершение программы...\n"); //сообщение пользователю
						return(0); //аварийное завершение программы
					}
					*(str + i) = getchar(); //ввод полного слова
				}
				i = 0;
				flag = 0;
				while (*(str + i) != '\n')
				{
					if (*(str + i) == ' ')
					{
						printf("введите ОДНО слово !\n"); //сообщение пользователю
						flag = 1;
						break;
					}
					i++;
				}
				if (flag == 0)
				{
					if (tmp != NULL)
					{
						if (tmp->aft == NULL && tmp->bef == NULL) //если список из одного слова
						{
							printf("В списке содержится один элемент, новый элемент добавлен до рабочего указателя\n"); //сообщение пользователю
							pushBack(list, str);
							s = list->head;
							t = list->tail;
						}
						else
						{
							if (tmp->aft != NULL)
							{
								insertNode(tmp, str);
							}
							else
							{
								pushFront(list, str);
								s = list->head;
								t = list->tail;
							}
						}
					}
					else
					{
						pushFront(list, str);
						s = list->head;
						t = list->tail;
					}
				}
			}
			else
			{
				printf("Сначала введите первый элемент!\n"); //сообщение пользователю
			}
		}
		if (comm == 20) //если команда 20
		{
			deleteList(list); //удаление списка
			return (2); //выход "в начать работу со списком"
		}
		if (comm == 21) //если команда 20
		{
			if (list->head != NULL && list->tail != NULL)
			{
				printbackward(list); //распечатать список в обратном порядке
			}
			else
			{
				printf("Список пуст!\n");
			}
		}
		if (list->head != NULL && list->tail != NULL) //если список не пуст
		{
			printf("Список:"); //сообщение пользователю
			printList(list); //вывод списка
			printf("\n       "); //выделение места под указатель
			while (s != tmp)
			{
				int i = 0;
				while (*(s->slovo + i) != '\n') //пока слово не закончилось
				{
					printf(" "); //делаем необходимый отступ
					i++;
				}
				printf(" ");
				s = s->aft; //сдвиг рабочего указателя на следующее слово
			}
			printf("^ "); //и отображаем положение текущего указателя
			printf("\n"); //переход на новую строку
			printf("Список в обратном порядке:");
			printbackward(list);
			printf("\n                          ");//делаем необходимый отступ
			while (t != tmp)
			{
				int i = 0;
				while (*(t->slovo + i) != '\n') //пока слово не закончилось
				{
					printf(" "); //делаем необходимый отступ
					i++;
				}
				printf(" ");
				t = t->bef;
			}
			printf("^ \n");
		}
	}
}

int main() //главная функция - начать работу со списком
{
	SetConsoleCP(1251); //русский язык ввода консоли
	SetConsoleOutputCP(1251); //русский язык вывода консоли
	DLList* list; //создание списка
	int c = 2; //команда для начала работы со списком
	while (c != 0) //пока не вышли из программы
	{
		list = createList(); //выделение памяти под список
		printf("Проведём работу с двусвязным циклическим списком слов.\n"); //сообщение пользователю
		printf("Введите 1, чтобы начать работу с двусвязным циклическим списком слов списком или введите 0, чтобы выйти из програмы.\n"); //сообщение пользователю
		scanf_s("%d", &c); //ввод команды пользователем
		system("cls"); //очистка консоли
		if (c == 1) //при вводе 1
		{
			c = menu(list); //вывод меню
		}
		else
		{
			if (c != 0) //если ввод некорректный
			{
				printf("Пожалуйста, выберите 1 или 0.\n"); //сообщение пользователю
			}
		}
	}
	printf("До скорой встречи...\n"); //сообщение пользователю
	return (0); //завершение программы
}